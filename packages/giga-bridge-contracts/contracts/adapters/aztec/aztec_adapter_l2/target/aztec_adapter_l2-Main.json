{"transpiled":true,"noir_version":"1.0.0-beta.11+5b65f9637e85a4177692c3190cb35ea678fb15e9-aztec","name":"Main","functions":[{"name":"initialize","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"aztec_l1_adapter","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tZnbbhs5DIbfxde50IEHqa9SFIWbuoUBwwncZIFFkXdfUiLpuIsZeO3sTfgNY/0jihSlOL8333ffXn9+3R9/PP3afPr8e/PttD8c9j+/Hp4ety/7p6N4f2+S/mhl86k9bBoP0/M0NExO2aw9Z3vOaLZPW8Bsm7ZWs6LaxWKblopZ87M9sz03e240bU9m0WwftiQwO3VLrmZFh8WWbJamrcksmO3TQjVr47CYtWcyHcJp2XR4Ptckn89ZgQx0hSa4p7inuEdnMwEcuoFOaEIz0CnlokAGlBzAQJctw8MGkg5HBTYY8xmADt1AkzZB3yXhQC0ObADuAfege9A95B5SHUk7MBi07EAGvTjwBNQay10BHbqBpnVAkVElKZCBruEEeVfJCt1ApzpApzqAbZ2RbZ2xoUEvDjyBUnWwFFC2FFC2FFBJDpYCAksBkaWAyFJAnB3QwVJADRwsBdSLgy0vp+Lgnuye7J7inmIp4GopYMgOlgLG4mApYLIUMKGDpYDZUsBaY6UqaAokUtZeMaFPaLotB+jECglUmU+RiTVdnwlkgMkBHLqBrmHpCmygjWKCe5p7mnu6e7p5uqayoAIb6HaYgAaaygkyjZoUuoF2sVoVZHhVQe1jA7TmJ/iv2D3snuYeXbEB2s4moEOfkJOunVFz0vo3UtHRibWdGJGTbgYjDOpOAEHNCUUZ8iB20piMwsfh4/DppjZCJ43MCIK6UdY8QBnETpoJI3TS6gVUAh1L46SpQeyk9WqETtqajXQG43Ti5tRqUPh6+Lr7SqpB4cuqB4Oak244I3LSLEAfhEESB9ZxQqKTFr4RW7zjoDHCoO6kmxDHO7pHXvSIHlRTDtJ36IiaU9DZp3MZn9NSnyNqCvLVrbpVjZpTZKFi+Cg+RzGXyELleEeLsd3aQgadsxEGdSete2SlmmdLECInCN9YU80RjDWddPZpvJoFIPARnILYqZWg5qS1YeQ+TCXI54I5Bfk7sPhYHMeo5g1HF56EQd1JV5eSkp8VQuTUwqf7jXRHoe43o7NP9Ej3ESU7VmSjpCB2GofFpOZUa1D4ID4HPhfC0MN4B8VY9nip5SAM8nipe7zs1xMhfweX8BWPjWsKOvs8XgafC8f85uE2iEqQxzaPtUnha/G5FnPpodf9HW1est7eHjZ+m/76ctrt9DL97notl+7n7Wl3fNl8Or4eDg+bv7aH1/GhX8/b47Av25P8VtZhd/wuVgR/7A87pbeH8+i0PFSqGG20lmII4KVCXlZAwmIKKAkKhdzwQqIsS0CpZBKySWFRoi5LyHXD45DMlJCQS/SFBKxIgJ7UUwJaWpTAZYkaSwEyyAWkwV8I0LJAyT2bQimpL0rwSj703jLTUdNNAp1NgKRGbwmiNJ+CnGhlUSKv1SWWFHUJfKMG9dBo/TaNmkKjlrassVabUKKu6CaFDl7ccn+8SUHuej4JuZwtpzWv5BWAvDhBDrXzNu3/YTn1omPLiTemtUaBCrabND4ilFyjQuXcv2mjcPa+Jxe05c1ayv+rIQdwhELcbtOQtusa3Jc3fcF7N8qawnUbZU3h2o1S2t3Vtbqc/dx3elnpoSt9nJPPAvld6/rXqZrXsloxNixXPjdRuoylrsRSKyavDeGKSyKrwXQvc7nN0nIwsJbac/NJ9K7A/shLxfsvCZXuvSVUvv+aUNu9x/zqLK485+EDznn4gHN+NZYr2yjU+1sgwL0tcE3huhYIcH8LBL67Ba4u50e0QEzRAnm5a+BKdVX5HseXQ76JT7DUvXBlIlW/S3CRiz+0/hRZ66MIcU5XlG+9l0RWyyP5tu/lxgIjX47OeG+JriisnvNXRbGqcFUUV941VhRWr/VXRbGqcFUUV/5p8afCF3ncPu5PF//ye1Op03777bCzxx+vx8d3v335+9l/4/8yfD49Pe6+v552qnT+v6H8+FyZH+QS/0W/7R2P+aEyfXnTt/8D"},{"name":"receive_root","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"private"},{"name":"root_type","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"bridge_message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2550444873539515884":{"error_kind":"string","string":"Trying to read from uninitialized PublicImmutable"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7043145299448266897":{"error_kind":"string","string":"L1-to-L2 message is already nullified"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13293000217372736598":{"error_kind":"string","string":"Tried to consume nonexistent L1-to-L2 message"},"14156770082850582201":{"error_kind":"string","string":"invalid root type"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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"},{"name":"update_leaf","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"leaf_index","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"leaf_value","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"2550444873539515884":{"error_kind":"string","string":"Trying to read from uninitialized PublicImmutable"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tZrbbhw5Dobfxde+0JlSXmUQBE7iDAwYTuBJFlgEefflL/FnJ7MoodCd3Li+YrdY4kGUWO3vdx8f33/7+93Ty6fP/9y9+ev73fvXp+fnp7/fPX/+8PD16fOLSr/fBfwZ9e5Nvr+LQe8arnoveo1633Gtdh3rmopd7T7bfbb7ku0q61qTXdu6tmhX0yv2HFE9ERORYdAzoRsMSoZJUsgEMYiR0AxSIFQCHlEUaiAUAj9qlDRKhBLpBj0RxGBEQluQQyBUAhQmhZgJ3SAlQjPIkVAJHF4KgZJKhVUMGhU2ShDvWO/vyny6APCRhqDMpwNyIFSDojNMQQHeSFFBMkEMeiRUgxEIOtWUAX1BReAWUBIpiZQkShIlSLY4AN2gJEIzQExTAVSCzjljeMuEbiCUCCWdEsR0AmK6oC1oiOmCSsAj9FkNrltQCPyoUFIoqZTUboB4LRADiYRm0PkI+HkBFGpwGxbIgr5AQiI0AyyQBZVgwwVrewGHZw7PYjCdqYVCpjMndAOhRCjplExnAqYzJ7QFfTpzQiXgEZqZHSmxQAxSNJhe1XD3psNLABRCN5BEaAZI0QX6rJIAwwApusAkIxQCJZGSSAlKStEEGFinC7oBCuGCYYBwL8B3NHAD4V7QDFAOF2CUrtMBHy4QA/iwNEBboMW7OA1SNlcrNRKWi9EgzSyc1IJTdbJgxCDZSUg9koYFJMZkEYlzrzDqpJycGqlEJ4uL0iDV4uSy5rLmMnGZuKxbfHT7ik4WoTh3D6NBisXJohRTSk6NlIMTxq6tEfrGpE7CvrcIO98izLTGuYnq/GqaNIwyZmUkJCxao0aCn2uZVJwGKbssu6y4rLisugzRr2FSceokLCYjzKCCEH0j2LGOAThHxEk6tmGmBbVnEexoMkltE+grid4oyJJFyBKjRiqqWSZh/UwflJadXIaZyiIhdZd11SeIbxn0aRn0c8U6MmI8amSM6vT4oovMv5ezk+srfMbclhbBu3OlrG1oEuZs1Eio84LI1MHV02bGLnJZhG11kpCSy5CxgpXcMldZw/wWleI0SNg3F7G2Kl1k/j3xuYjr6/6MwbESaK8E2isxOdFeSbRXMm2Tkp1cVmmbVNorzWWN9opwLuLzk16caIcM2ja3IqOLjN+bu5ER9c39aFH2sfBpWtRJmLNRI8G7grXQsV/inKQn3ezksgHb+iQxGiE5wV74b0Q7fykJCWvLaJByJZXgdJH592p2cn3NnyE+Fj7tYdIgDZchd3vCCR1zNmqk2WUswoh5kp+dxqQkJNQDI4zFCTtgVr2CZi8xCTlphOc20JzfJKx4o2YU56wWCSm6DNnZBYRIG7ls9j6LBmn2P4uEVH0sVk8fIKyPESYVp26UMCujRkJ8jdTekSYNEiJt5LLssuyy4rLiMqz4MRsjxNeok+BTo0GCT426eTwhT42a0ex+jGB5BOFYP32QZ3wnoTYZVSc8DZGe7cy0fPYzRi7DOh/zGaidi7rLsDMNxDK7x/OgTwvqqRF9X2JxGqTksuTfy8nJ9ZXgNMf++HF/x5773dfXx0e03D814dqaf3l4fXz5evfm5dvz8/3dfx6ev80v/fPl4WVevz686qeq8/Hlo15V4aen50fQj/vL6HA8VCtcsdFauoorqL9qiMcaUtGNx1QoR3EdbfyiIx3r0JYWZX7qUG7hSMfOkl7FLZF6ZEnZaNCqlqhCD+SHs6g7SzK2GrNE0+oaS7Qe+zRKP7JkqwFnIdMw0lUaogc1xEMN41iDbs/UoPvzxQ96SP01tTazyJXxKDqKGrT+/Kphl51qCO3Qyn6sY5Od1cNRc7hOw2BqtlivsyPlix0lXadDz1PUITtL2p/VgbMjs7NJv06HCLNLS9jGH9sMTZ6g7SoNo3Cta9t+lQY9YnjJ0aPKoY60ya5SGnNDd5bLPOI47059j+EFIx27c7NWcebyitHbUcVIm+KpL7a4GWkrkS+G9Pqrjo0l0oTJJRLkWIdsHJoyk1y373Kso+/mMarPI6fD8pd+QwnNN5fQ/BtKaL65hOabS+jWjtQ5CT1xHud43mQo2nyuk1rkSh3N11rt4zod+bJeczouPbnfWv52Gs6Vv52Gs+WvxJvL396dxU/B2lBcGRLPULzeukrH7zAlZs/QWPp1K+XkJl/kz+o4e1DY6jh5UKjh1pWy03Bupew0nF0pNd+cXlt3njwobLdoaZctutfD7bVuz3+jt0tcRz3s1WTbrIV+adZSOWxdt9bE4db8tOD+z5rdRi+d89C3kIfTaLt9PpfA4CofKzl/ADuOzFaHVPqj9Z8y5N862iZR42Wrxk53ybJ/ZWrbdPM5tM6CrD+WhH7o1V07H8LFq/pD2mE739ruCJarK9Ffp8sV7wT04MUM0ZeM4eh03XZ7rb439h0Kb38PbRm7NOsXW3LfrLtdNQycx0hX1tPGYjik3lqRNxq2p59TVmw1nLLi5Also2Hbwp6yYqvhlBUn22i58vVIvryD1N9Dr3zFcq4/6LefRXcqzh7g9jo8JviZ+zodJ8+zWx0n26W9jnPt0t6Wc+1Sv7ld6je3S/03tEvjD6foyXap31w9+83Vs19XPd/q7cOHp9df/inyB1S9Pj28f36020/fXj789OnX/37hJ/ynyi+vnz88fvz2+ghNl/+s1D9/1VDua6pv9ZdQ3Gow7mvIuI34VN+G1Fze/sBk/gc="},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"1752556835457866331":{"error_kind":"string","string":"No public functions"}}},"bytecode":"JwAABAEqAAABBRhSVSgKJhpbPAAAAQ==","debug_symbols":"XY1bCoAgEEX3Mt+toK1EiI9RBkRl0iDEvWeRIH3ee+6jgkFVnKBg4wHrVkExeU9O+Khlphi6W9sCQ4rMiN2CiW97D0hN/C+dkkkqj5+0JeiJ5isNMk4TR42mMD5LL2t7uwE="}],"outputs":{"globals":{"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Main"}},{"name":"fields","value":{"fields":[{"name":"aztec_l1_adapter","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"owner_of_leaf_index","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"root_history","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"giga_root","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"aztec_l1_adapter","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"Main::initialize_parameters"}}],"kind":"struct","path":"Main::initialize_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"root_type","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"bridge_message_leaf_index","type":{"kind":"field"}}],"kind":"struct","path":"Main::receive_root_parameters"}}],"kind":"struct","path":"Main::receive_root_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"leaf_index","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"leaf_value","type":{"kind":"field"}}],"kind":"struct","path":"Main::update_leaf_parameters"}}],"kind":"struct","path":"Main::update_leaf_abi"}]}},"file_map":{"108":{"path":"/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/macros/storage.nr","source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields = storage_layout_fields.push_back(\n            quote { pub $name: dep::aztec::state_vars::storage::Storable },\n        );\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::state_vars::storage::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"},"177":{"path":"/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable:\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `PrivateMutable`\n///     - `PrivateImmutable`\n///     - `PrivateSet`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, T, Context> HasStorageSlot<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Initializes a new Map state variable.\n    ///\n    /// This function is usually automatically called within the #[storage]\n    /// macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`.\n    ///               The Context determines which methods of this struct will\n    ///               be made available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this Map within the contract.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart\n    ///                    contract dev shouldn't have to worry about this, as\n    ///                    it's managed behind the scenes.\n    /// * `state_var_constructor` - A function that creates the value type (V)\n    ///                             given a context and storage slot. This is\n    ///                             typically the constructor of the state\n    ///                             variable type being stored in the Map.\n    ///\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PrivateMutable, PublicMutable, etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<ValueNote>)\n    /// let user_balance = storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"18":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"},"185":{"path":"/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::HasStorageSlot,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using O fields) and its hash (1 field), requiring O = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let O: u32> HasStorageSlot<O> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N = O>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    /// Initializes a new PublicImmutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`PrivateContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the historical block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   historical block header that is being referenced by this private function.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"},"187":{"path":"/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[public] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let M: u32> HasStorageSlot<M> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    /// Initializes a new PublicMutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`UtilityContext`. The Context determines\n    ///               which methods of this struct will be made available to the calling\n    ///               smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"19":{"path":"std/hash/mod.nr","source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"},"219":{"path":"/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr","source":"use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.historical_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n"},"226":{"path":"/home/jimjim/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr","source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"3":{"path":"std/array/mod.nr","source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"},"316":{"path":"/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        // Q: I don't understand this comment. We could still compute a siloed nullifier from a zero contract address.\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert_eq(input[in_len - remainder + i], 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"},"344":{"path":"/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"377":{"path":"/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"389":{"path":"/home/jimjim/nargo/github.com/noir-lang/sha256/v0.2.0/src/sha256.nr","source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let (mut h, mut msg_block, mut msg_byte_ptr) =\n            process_full_blocks(msg, message_size, INITIAL_STATE);\n\n        finalize_sha256_blocks(msg, message_size, N, h, msg_block, msg_byte_ptr)\n    }\n}\n\npub(crate) unconstrained fn __sha_var<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = initial_state;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n\n    finalize_last_sha256_block(h, message_size, msg)\n}\n\n// Helper function to finalize the message block with padding and length\npub(crate) unconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    __sha_var(msg, message_size, INITIAL_STATE)\n}\n\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    mut h: STATE,\n) -> (STATE, MSG_BLOCK, u32) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    let mut msg_byte_ptr = 0;\n    let num_blocks = N / BLOCK_SIZE;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n        // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        // Verify the block we are compressing was appropriately constructed\n        let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n        if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n    (h, msg_block, msg_byte_ptr)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\npub(crate) unconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u32) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\n#[inline_always]\nfn rshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        if 8 * shifts >= 32 {\n            0\n        } else {\n            item >> (8 * shifts)\n        }\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    msg_block[INT_SIZE_PTR] = (len_bytes[0] as u32) << 24\n        | (len_bytes[1] as u32) << 16\n        | (len_bytes[2] as u32) << 8\n        | (len_bytes[3] as u32);\n\n    msg_block[INT_SIZE_PTR + 1] = (len_bytes[4] as u32) << 24\n        | (len_bytes[5] as u32) << 16\n        | (len_bytes[6] as u32) << 8\n        | (len_bytes[7] as u32);\n\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    std::static_assert(\n        INT_SIZE_PTR + 2 == INT_BLOCK_SIZE,\n        \"INT_SIZE_PTR + 2 must equal INT_BLOCK_SIZE\",\n    );\n    let reconstructed_len_hi = msg_block[INT_SIZE_PTR] as Field;\n    let reconstructed_len_lo = msg_block[INT_SIZE_PTR + 1] as Field;\n\n    let reconstructed_len: Field =\n        reconstructed_len_hi * TWO_POW_32 as Field + reconstructed_len_lo;\n    let len = 8 * (message_size as Field);\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\npub(crate) fn finalize_sha256_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    total_len: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: u32,\n) -> HASH {\n    let modulo = total_len % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let num_blocks = total_len / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n        // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n        if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n            verify_msg_block_padding(msg_block, msg_byte_ptr);\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: separate verification function\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (mut h, _, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (mut h, mut msg_block, mut msg_byte_ptr) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks(msg, real_message_size, N, h, msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"},"50":{"path":"/home/jimjim/Desktop/giga-bridge/packages/giga-bridge-contracts/contracts/adapters/aztec/aztec_adapter_l2/src/main.nr","source":"use dep::aztec::macros::aztec;\n\ncontract Main {\n    use aztec::{\n        context,\n        event::event_interface::{emit_event_in_private, MessageDelivery},\n        oracle::random::random,\n        event::event_interface::{emit_event_in_public},\n        macros::{events::event, functions::{internal, private, public, utility}, storage::storage},\n        note::{note_getter::get_note},\n        state_vars::{PublicImmutable, Map, PublicMutable, storage::HasStorageSlot, private_mutable::PrivateMutable},\n        protocol_types::{\n            hash::poseidon2_hash, abis::block_header::BlockHeader,\n            address::{AztecAddress, EthAddress},\n            storage::map::derive_storage_slot_in_map,\n            traits::Serialize,\n        },\n        utils::{\n            with_hash::WithHash::{self},\n        },\n    };\n\n    //TODO use enums once available\n    global NOT_A_ROOT: u8 = 0; // mappings default to zero, this causes keys not set in rootHistory to default to NOT_A_ROOT\n    global GIGA_ROOT: u8 = 1;\n    global SYNC_ROOT: u8 = 2;\n\n    #[storage]\n    struct Storage<Context> {\n        aztec_l1_adapter: PublicImmutable<EthAddress, Context>,\n        owner_of_leaf_index: Map<AztecAddress, PublicMutable<u128, Context>, Context>,\n        // TODO use enums once available\n        root_history: Map<Field, PublicImmutable<u8, Context>, Context>,\n        giga_root: PublicMutable<Field, Context>\n    }\n\n    #[public]\n    fn initialize(aztec_l1_adapter: EthAddress) {\n        storage.aztec_l1_adapter.initialize(aztec_l1_adapter); \n    }\n\n    #[public]\n    fn update_leaf(leaf_index: u128, leaf_value: Field) {\n        // make sure msg.sender is the contract that is registered on L1\n        // message l1 adapter updateFromL2(leaf_index, leaf_value, msg.sender)\n        let block_number: u32 = context.block_number();\n        let registrant: AztecAddress = context.msg_sender();\n        let content_hash: Field = poseidon2_hash([leaf_index as Field, leaf_value as Field, block_number as Field, registrant.inner]);\n        let aztec_l1_adapter: EthAddress = storage.aztec_l1_adapter.read();\n        context.message_portal(aztec_l1_adapter, content_hash);\n    }\n\n    #[public]\n    fn receive_root(root: Field, root_type: u8, bridge_message_leaf_index: Field) {\n        assert((root_type == GIGA_ROOT) | (root_type == SYNC_ROOT) , \"invalid root type\");\n\n        // no secrets here!\n        let secret: Field = 0;\n        let content_hash: Field = poseidon2_hash([root, root_type as Field]);\n        let aztec_l1_adapter: EthAddress = storage.aztec_l1_adapter.read();\n        context.consume_l1_to_l2_message(content_hash, secret, aztec_l1_adapter, bridge_message_leaf_index);\n        storage.root_history.at(root).initialize(root_type);\n        if (root_type == GIGA_ROOT) {\n            storage.giga_root.write(root);\n        }\n    }\n}\n"},"69":{"path":"/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between a #[public] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[public] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[public] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[public]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases, and is enforced by the protocol's kernel circuits.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the account or contract that called\n    ///   this function\n    ///\n    /// # Examples\n    /// ```rust\n    /// #[aztec(public)]\n    /// fn transfer(context: &mut PublicContext, to: AztecAddress, amount: u64) {\n    ///     let sender = context.msg_sender();\n    ///     // Only the sender can transfer their own tokens\n    ///     assert(sender == get_token_owner(), \"Unauthorized\");\n    /// }\n    /// ```\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    /// * Globally visible unlike private execution where it's contract-local\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[public] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"},"75":{"path":"/home/jimjim/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"}}}